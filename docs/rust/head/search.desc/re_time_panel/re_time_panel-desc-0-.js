searchState.loadedDescShard("re_time_panel", 0, "Rerun Time Panel\nA panel that shows entity names to the left, time on the …\nShow the data density over time for a data stream.\nEnsures that all required store subscribers are correctly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDraw the hovered/selected highlight background for a …\nReturns a scroll delta\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe right side of the entity name column; updated during …\nVisually separate the different time segments\nWidth of the entity name columns previous frame.\nWhich source is the time panel controlling\nUi elements for controlling time.\nA vertical line that shows the current time.\negui uses <code>f32</code> precision for all screen-space ui …\nThe time axis view, regenerated each frame.\nFind a nice view of everything.\nAll chunks will be rendered as individual events.\nAll sorted chunks will be rendered as individual events, …\nHigher = slower, but more accurate.\nPersistent data for painting the data density graph.\nWe need some margin because of the blurring.\nAll chunks will be rendered whole.\nWe return a float so user can interpolate between buckets.\nNumber of datapoints per bucket. <code>0 == min_x, n-1 == max_x</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf a sorted chunk has fewer events than this we show its …\nIf an unsorted chunk has fewer events than this we show …\nIf there are more chunks than this then we NEVER show …\nThe maximum density we’ve seen so far this frame.\nReturn something in the 0-1 range.\nThe maximum density of the previous frame. This is what we …\nBlur the input slightly.\nCached information about a chunk in the context of a given …\nRecursive chunk timeline infos for a given timeline &amp; …\nFor each entity &amp; timeline, keeps track of all its chunks …\nAccesses the chunk\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll chunks used by the entity &amp; timeline, recursive for …\nAccesses the global store subscriber.\nTotal number of events in all <code>Self::recursive_chunks_info</code> …\nA piece-wise linear view of a single timeline.\nReturns <code>None</code> to signal an abort.\nReturns <code>None</code> to signal an abort.\nCollapse any gaps larger or equals to the given threshold.\nReturns the argument unchanged.\nFirst determine the threshold for when a gap should be …\nCalls <code>U::from(self)</code>.\nTotal uncollapsed time.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHow much of the gap use up to expand segments visually to …\nThe ideal gap between time segments.\nReturns the argument unchanged.\nSze of the gap between time segments.\nCalls <code>U::from(self)</code>.\nDoes NOT match any of the above. Instead this is a tight …\nMatches <code>Self::x</code> (linear transform).\nThe range on the x-axis in the ui, in screen coordinates.\nHuman-readable description of a duration")