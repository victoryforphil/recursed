searchState.loadedDescShard("re_protos", 0, "This crate contains generated types for the remote store …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerated types for the remote store gRPC service API v0.\nComponent describes semantic data that can be used by any …\nUsed to select a component based on its EntityPath and …\nsupported encoder versions for encoding data See <code>RerunData</code> …\nThe unique identifier of an entity, e.g. <code>camera/3/points</code> …\nunique recording identifier. At this point in time it is …\nRerunChunk is arrow IPC encoded RecordBatch that has …\narrow IPC serialized schema\nSpecifies how null values should be filled in the returned …\nA date-time represented as nanoseconds since unix epoch\nUsed to telect a time column.\nA 64-bit number describing either nanoseconds, sequence …\nA time range between start and end time points. Each 64 …\nA recording can have multiple timelines, each is …\n/ The specific <em>columns</em> to sample from the final view …\nNested message and enum types in <code>ColumnSelector</code>.\nencoder version used to encode the data\nThe index used to filter out <em>rows</em> from the view contents. …\nThe range of index values used to filter out <em>rows</em> from the …\nThe specific index values used to filter out <em>rows</em> from the …\nThe component column used to filter out <em>rows</em> from the view …\nInitialized to something random on each thread, then …\nWhether the view_contents should ignore columns …\nWhether the view_contents should ignore semantically empty …\nWhether the view_contents should ignore columns …\ncomponent name needs to be a string as user can define …\nData payload is Arrow IPC encoded RecordBatch\nSpecifies how null values should be filled in the returned …\nApproximate nanoseconds since epoch.\nTODO(zehiko) we need to add support for other types of …\nTODO(zehiko) support for other ranges for other index …\nTODO(zehiko) we need to add support for other types of …\nThe specific index values used to sample <em>rows</em> from the …\nThe subset of the database that the query will run on: a …\nThe payload is encoded as Arrow-IPC.\nCorresponds to <code>LogMsg::ArrowMsg</code>. Used to transmit actual …\nCorresponds to <code>LogMsg::BlueprintActivationCommand</code>.\nThe recording came from the C++ SDK.\nThe file came from the command line.\nThe type of compression used on the payload.\nInformation about the Rust SDK that created the recording.\nThe file was dragged into the viewer.\nThe encoding of the message payload.\nThe recording came from a file.\nThe file was opened using a file dialog.\nA recording which came from a file.\nDetermines where the file came from.\nTODO(#8631): Remove <code>LogMsg</code>\nLZ4 block compression.\nNo compression.\nThe recording came from some other source.\nThe recording came from the Python SDK.\nVersion of the Python SDK that created the recording.\nThe recording came from the Rust SDK.\nThe recording was produced using a data loader, such as …\nCorresponds to <code>LogMsg::SetStoreInfo</code>. Used to identify a …\nInformation about a recording or blueprint.\nThe source of a recording or blueprint.\nA newtype for <code>StoreSource</code> payload.\nWhat kind of source a recording comes from.\nWe don’t know what encoding the payload is in.\nWe don’t know anything about the source of this …\nWe don’t know where the file came from.\nThe file was served over HTTP.\nThe recording came from some action in the viewer.\nUser-chosen name of the application doing the logging.\nThe ID of the blueprint to activate.\nCompression algorithm used.\nCrate version encoded using our custom scheme.\nEncoding of the payload.\nStore source payload. See <code>StoreSourceKind</code> for what exactly …\nThe new store info.\n/ True if the recording is one of the official Rerun …\nDetermines what is encoded in <code>extra</code>.\nVersion of LLVM used by the Rust compiler.\nNested message and enum types in <code>LogMsg</code>.\nWhether to make the blueprint active immediately.\nWhether to make the blueprint the default.\nArrow-IPC encoded schema and chunk, compressed according …\nA time-based UID that is used to determine how a <code>StoreInfo</code> …\nVersion of the Rust compiler used to compile the SDK.\nWhen the recording started.\nThe ID of the store that this message is for.\nUnique ID of the recording.\nWhere the recording came from.\nVersion of the store crate.\nA message that contains an Arrow-IPC encoded message.\nA message that contains a blueprint activation command.\nA message that contains a new store info.\nEncoding / decoding error\nDataframePart is arrow IPC encoded RecordBatch\nError codes for application level errors\nTODO(jleibs): Eventually this becomes either …\nmetadata database access error\nobject store access error\nApplication level error - used as <code>details</code> in the …\nunused\nerror code\nColumn projection - define which columns should be …\nhuman readable description of the recording\nencoder version used to encode the data\nTODO(zehiko) we need to expand this to become something …\nFilter specific recordings that match the criteria …\nunique identifier associated with the request (e.g. …\nhuman readable details about the error\n(optional) any additional metadata that should be …\nData payload is Arrow IPC encoded RecordBatch\nraw bytes are TransportChunks (i.e. RecordBatches) encoded …\npayload is raw bytes that the relevant codec can interpret\nquery to execute\nunique identifier of the recording\nunique identifier of the recording\nFiltering is very simple right now, we can only select …\nGenerated client implementations.\nGenerated server implementations.\nrecording storage url (e.g. s3://bucket/file or …\ntype of recording\nServer streaming response type for the FetchRecording …\nServer streaming response type for the QueryCatalog method.\nServer streaming response type for the Query method.\nGenerated gRPC service name\nGenerated trait containing gRPC methods that should be …\ndata API calls\nmetadata API calls\nTODO(zehiko) support registering more than one recording …\nGenerated client implementations.\nGenerated server implementations.\nSimple buffer for messages between SDKs and viewers.\nGenerated trait containing gRPC methods that should be …\nSimple buffer for messages between SDKs and viewers.\nServer streaming response type for the ReadMessages method.\nGenerated gRPC service name\nTODO(jan): Would it be more efficient to send a “message …\nComponent describes semantic data that can be used by any …\nUsed to select a component based on its EntityPath and …\nsupported encoder versions for encoding data See <code>RerunData</code> …\nThe unique identifier of an entity, e.g. <code>camera/3/points</code> …\nunique recording identifier. At this point in time it is …\nRerunChunk is arrow IPC encoded RecordBatch that has …\narrow IPC serialized schema\nSpecifies how null values should be filled in the returned …\nA date-time represented as nanoseconds since unix epoch\nUsed to telect a time column.\nA 64-bit number describing either nanoseconds, sequence …\nA time range between start and end time points. Each 64 …\nA recording can have multiple timelines, each is …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\n/ The specific <em>columns</em> to sample from the final view …\nNested message and enum types in <code>ColumnSelector</code>.\nReturns the enum value of <code>encoder_version</code>, or the default …\nencoder version used to encode the data\nThe index used to filter out <em>rows</em> from the view contents. …\nThe range of index values used to filter out <em>rows</em> from the …\nThe specific index values used to filter out <em>rows</em> from the …\nThe component column used to filter out <em>rows</em> from the view …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>EncoderVersion</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>SparseFillStrategy</code>, or <code>None</code> if <code>value</code> …\nConverts an <code>i32</code> to a <code>StoreKind</code>, or <code>None</code> if <code>value</code> is not a …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nInitialized to something random on each thread, then …\nWhether the view_contents should ignore columns …\nWhether the view_contents should ignore semantically empty …\nWhether the view_contents should ignore columns …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>EncoderVersion</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>SparseFillStrategy</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>StoreKind</code>.\nReturns the enum value of <code>kind</code>, or the default if the …\ncomponent name needs to be a string as user can define …\nData payload is Arrow IPC encoded RecordBatch\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>kind</code> to the provided enum value.\nSets <code>sparse_fill_strategy</code> to the provided enum value.\nReturns the enum value of <code>sparse_fill_strategy</code>, or the …\nSpecifies how null values should be filled in the returned …\nApproximate nanoseconds since epoch.\nTODO(zehiko) we need to add support for other types of …\nTODO(zehiko) support for other ranges for other index …\nTODO(zehiko) we need to add support for other types of …\nThe specific index values used to sample <em>rows</em> from the …\nThe subset of the database that the query will run on: a …\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nThe payload is encoded as Arrow-IPC.\nCorresponds to <code>LogMsg::ArrowMsg</code>. Used to transmit actual …\nCorresponds to <code>LogMsg::BlueprintActivationCommand</code>.\nThe recording came from the C++ SDK.\nThe file came from the command line.\nThe type of compression used on the payload.\nInformation about the Rust SDK that created the recording.\nThe file was dragged into the viewer.\nThe encoding of the message payload.\nThe recording came from a file.\nThe file was opened using a file dialog.\nA recording which came from a file.\nDetermines where the file came from.\nTODO(#8631): Remove <code>LogMsg</code>\nLZ4 block compression.\nNo compression.\nThe recording came from some other source.\nThe recording came from the Python SDK.\nVersion of the Python SDK that created the recording.\nThe recording came from the Rust SDK.\nThe recording was produced using a data loader, such as …\nCorresponds to <code>LogMsg::SetStoreInfo</code>. Used to identify a …\nInformation about a recording or blueprint.\nThe source of a recording or blueprint.\nA newtype for <code>StoreSource</code> payload.\nWhat kind of source a recording comes from.\nWe don’t know what encoding the payload is in.\nWe don’t know anything about the source of this …\nWe don’t know where the file came from.\nThe file was served over HTTP.\nThe recording came from some action in the viewer.\nUser-chosen name of the application doing the logging.\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nThe ID of the blueprint to activate.\nReturns the enum value of <code>compression</code>, or the default if …\nCompression algorithm used.\nCrate version encoded using our custom scheme.\nReturns the enum value of <code>encoding</code>, or the default if the …\nEncoding of the payload.\nStore source payload. See <code>StoreSourceKind</code> for what exactly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>Compression</code>, or <code>None</code> if <code>value</code> is not …\nConverts an <code>i32</code> to a <code>Encoding</code>, or <code>None</code> if <code>value</code> is not a …\nConverts an <code>i32</code> to a <code>StoreSourceKind</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>FileSourceKind</code>, or <code>None</code> if <code>value</code> is …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nThe new store info.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n/ True if the recording is one of the official Rerun …\nReturns <code>true</code> if <code>value</code> is a variant of <code>Compression</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>Encoding</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>StoreSourceKind</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>FileSourceKind</code>.\nReturns the enum value of <code>kind</code>, or the default if the …\nReturns the enum value of <code>kind</code>, or the default if the …\nDetermines what is encoded in <code>extra</code>.\nVersion of LLVM used by the Rust compiler.\nNested message and enum types in <code>LogMsg</code>.\nWhether to make the blueprint active immediately.\nWhether to make the blueprint the default.\nArrow-IPC encoded schema and chunk, compressed according …\nA time-based UID that is used to determine how a <code>StoreInfo</code> …\nVersion of the Rust compiler used to compile the SDK.\nSets <code>compression</code> to the provided enum value.\nSets <code>encoding</code> to the provided enum value.\nSets <code>kind</code> to the provided enum value.\nSets <code>kind</code> to the provided enum value.\nWhen the recording started.\nThe ID of the store that this message is for.\nUnique ID of the recording.\nWhere the recording came from.\nVersion of the store crate.\nA message that contains an Arrow-IPC encoded message.\nA message that contains a blueprint activation command.\nA message that contains a new store info.\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nEncoding / decoding error\nDataframePart is arrow IPC encoded RecordBatch\nError codes for application level errors\nTODO(jleibs): Eventually this becomes either …\nmetadata database access error\nobject store access error\nApplication level error - used as <code>details</code> in the …\nunused\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nReturns the enum value of <code>code</code>, or the default if the …\nerror code\nColumn projection - define which columns should be …\nhuman readable description of the recording\nReturns the enum value of <code>encoder_version</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nencoder version used to encode the data\nTODO(zehiko) we need to expand this to become something …\nFilter specific recordings that match the criteria …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>RecordingType</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>ErrorCode</code>, or <code>None</code> if <code>value</code> is not a …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nunique identifier associated with the request (e.g. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>RecordingType</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>ErrorCode</code>.\nhuman readable details about the error\n(optional) any additional metadata that should be …\nData payload is Arrow IPC encoded RecordBatch\nraw bytes are TransportChunks (i.e. RecordBatches) encoded …\npayload is raw bytes that the relevant codec can interpret\nquery to execute\nunique identifier of the recording\nunique identifier of the recording\nFiltering is very simple right now, we can only select …\nSets <code>code</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>typ</code> to the provided enum value.\nGenerated client implementations.\nGenerated server implementations.\nrecording storage url (e.g. s3://bucket/file or …\nReturns the enum value of <code>typ</code>, or the default if the field …\ntype of recording\nEnable decompressing responses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\ndata API calls\nmetadata API calls\nTODO(zehiko) support registering more than one recording …\nCompress requests with the given encoding.\nServer streaming response type for the FetchRecording …\nServer streaming response type for the QueryCatalog method.\nServer streaming response type for the Query method.\nGenerated gRPC service name\nGenerated trait containing gRPC methods that should be …\nEnable decompressing requests with the given encoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\ndata API calls\nmetadata API calls\nTODO(zehiko) support registering more than one recording …\nCompress responses with the given encoding, if the client …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerated client implementations.\nGenerated server implementations.\nSimple buffer for messages between SDKs and viewers.\nEnable decompressing responses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\nCompress requests with the given encoding.\nTODO(jan): Would it be more efficient to send a “message …\nGenerated trait containing gRPC methods that should be …\nSimple buffer for messages between SDKs and viewers.\nServer streaming response type for the ReadMessages method.\nGenerated gRPC service name\nEnable decompressing requests with the given encoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\nCompress responses with the given encoding, if the client …\nTODO(jan): Would it be more efficient to send a “message …")